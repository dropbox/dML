// This file is @generated by prost-build.
/// Synthesis request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynthesizeRequest {
    /// Text to synthesize
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Language code (en, ja, zh, etc.)
    #[prost(string, tag = "2")]
    pub language: ::prost::alloc::string::String,
    /// Voice ID (optional, uses default)
    #[prost(string, tag = "3")]
    pub voice_id: ::prost::alloc::string::String,
    /// Speech speed (0.5-2.0, default 1.0)
    #[prost(float, tag = "4")]
    pub speed: f32,
    /// Output audio format
    #[prost(enumeration = "AudioFormat", tag = "5")]
    pub format: i32,
}
/// Synthesis response (for unary)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynthesizeResponse {
    /// Complete audio data
    #[prost(bytes = "vec", tag = "1")]
    pub audio: ::prost::alloc::vec::Vec<u8>,
    /// Audio metadata
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<AudioMetadata>,
    /// Timing information
    #[prost(message, optional, tag = "3")]
    pub timing: ::core::option::Option<TimingInfo>,
}
/// Audio chunk (for streaming)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioChunk {
    /// Audio data chunk
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// True if this is the last chunk
    #[prost(bool, tag = "2")]
    pub is_final: bool,
    /// Metadata (only in first chunk)
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<AudioMetadata>,
    /// Timing info (only in final chunk)
    #[prost(message, optional, tag = "4")]
    pub timing: ::core::option::Option<TimingInfo>,
}
/// Audio metadata
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudioMetadata {
    /// Sample rate in Hz (e.g., 24000)
    #[prost(int32, tag = "1")]
    pub sample_rate: i32,
    /// Number of channels (1 = mono)
    #[prost(int32, tag = "2")]
    pub channels: i32,
    /// Bits per sample (16)
    #[prost(int32, tag = "3")]
    pub bits_per_sample: i32,
    /// Audio format
    #[prost(enumeration = "AudioFormat", tag = "4")]
    pub format: i32,
    /// Total samples (if known)
    #[prost(int64, tag = "5")]
    pub total_samples: i64,
}
/// Timing information
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimingInfo {
    /// Synthesis time in ms
    #[prost(int64, tag = "1")]
    pub synthesis_ms: i64,
    /// Translation time in ms (if applicable)
    #[prost(int64, tag = "2")]
    pub translation_ms: i64,
    /// Total processing time in ms
    #[prost(int64, tag = "3")]
    pub total_ms: i64,
}
/// TTS request (for bidirectional streaming)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TtsRequest {
    #[prost(oneof = "tts_request::Request", tags = "1, 2")]
    pub request: ::core::option::Option<tts_request::Request>,
}
/// Nested message and enum types in `TTSRequest`.
pub mod tts_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        Synthesize(super::SynthesizeRequest),
        #[prost(message, tag = "2")]
        Control(super::ControlCommand),
    }
}
/// Control commands for streaming
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ControlCommand {
    #[prost(enumeration = "control_command::Command", tag = "1")]
    pub command: i32,
}
/// Nested message and enum types in `ControlCommand`.
pub mod control_command {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Command {
        Unspecified = 0,
        /// Cancel current synthesis
        Cancel = 1,
        /// Pause streaming
        Pause = 2,
        /// Resume streaming
        Resume = 3,
        /// Flush buffer and continue
        Flush = 4,
    }
    impl Command {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMMAND_UNSPECIFIED",
                Self::Cancel => "COMMAND_CANCEL",
                Self::Pause => "COMMAND_PAUSE",
                Self::Resume => "COMMAND_RESUME",
                Self::Flush => "COMMAND_FLUSH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMAND_UNSPECIFIED" => Some(Self::Unspecified),
                "COMMAND_CANCEL" => Some(Self::Cancel),
                "COMMAND_PAUSE" => Some(Self::Pause),
                "COMMAND_RESUME" => Some(Self::Resume),
                "COMMAND_FLUSH" => Some(Self::Flush),
                _ => None,
            }
        }
    }
}
/// Status request
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatusRequest {
    /// Include detailed metrics
    #[prost(bool, tag = "1")]
    pub include_metrics: bool,
}
/// Status response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    /// Server version
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Server status (ready, busy, etc.)
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    /// Whether models are loaded
    #[prost(bool, tag = "3")]
    pub models_loaded: bool,
    /// Detailed metrics (if requested)
    #[prost(message, optional, tag = "4")]
    pub metrics: ::core::option::Option<ServerMetrics>,
}
/// Server metrics
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServerMetrics {
    #[prost(int64, tag = "1")]
    pub total_requests: i64,
    #[prost(int64, tag = "2")]
    pub successful_requests: i64,
    #[prost(int64, tag = "3")]
    pub failed_requests: i64,
    #[prost(int64, tag = "4")]
    pub total_synthesis_ms: i64,
    #[prost(int64, tag = "5")]
    pub active_connections: i64,
    #[prost(float, tag = "6")]
    pub average_latency_ms: f32,
}
/// Translation request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslateRequest {
    /// Text to translate
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Source language (e.g., "en")
    #[prost(string, tag = "2")]
    pub source_language: ::prost::alloc::string::String,
    /// Target language (e.g., "ja")
    #[prost(string, tag = "3")]
    pub target_language: ::prost::alloc::string::String,
}
/// Translation response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslateResponse {
    /// Translated text
    #[prost(string, tag = "1")]
    pub translated_text: ::prost::alloc::string::String,
    /// Timing information
    #[prost(message, optional, tag = "2")]
    pub timing: ::core::option::Option<TimingInfo>,
}
/// Combined translate + synthesize request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranslateAndSynthesizeRequest {
    /// Text to translate
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Source language (e.g., "en")
    #[prost(string, tag = "2")]
    pub source_language: ::prost::alloc::string::String,
    /// Target language (e.g., "ja")
    #[prost(string, tag = "3")]
    pub target_language: ::prost::alloc::string::String,
    /// Voice ID (optional)
    #[prost(string, tag = "4")]
    pub voice_id: ::prost::alloc::string::String,
    /// Speech speed
    #[prost(float, tag = "5")]
    pub speed: f32,
    /// Output audio format
    #[prost(enumeration = "AudioFormat", tag = "6")]
    pub format: i32,
}
/// Unary transcription request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranscribeRequest {
    /// Raw PCM16 audio (mono)
    #[prost(bytes = "vec", tag = "1")]
    pub audio: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate in Hz (default: 16000)
    #[prost(int32, tag = "2")]
    pub sample_rate: i32,
    /// Source language ("en", "ja", "auto")
    #[prost(string, tag = "3")]
    pub language: ::prost::alloc::string::String,
    /// Translate non-English speech to English
    #[prost(bool, tag = "4")]
    pub translate_to_english: bool,
}
/// Unary transcription response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranscribeResponse {
    /// Full transcript
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Average token confidence (0-1)
    #[prost(float, tag = "2")]
    pub confidence: f32,
    /// Total processing time in ms
    #[prost(int64, tag = "3")]
    pub total_ms: i64,
    /// Detected language (if auto)
    #[prost(string, tag = "4")]
    pub detected_language: ::prost::alloc::string::String,
}
/// Streaming audio input (client -> server)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudioInput {
    /// Raw PCM16 audio chunk (mono)
    #[prost(bytes = "vec", tag = "1")]
    pub audio: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate in Hz (default: 16000)
    #[prost(int32, tag = "2")]
    pub sample_rate: i32,
    /// True when this is the last chunk
    #[prost(bool, tag = "3")]
    pub end_of_stream: bool,
    /// Source language ("en", "auto" default)
    #[prost(string, tag = "4")]
    pub language: ::prost::alloc::string::String,
    /// Translate non-English speech to English
    #[prost(bool, tag = "5")]
    pub translate_to_english: bool,
    /// Optional streaming config (set on first chunk)
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<SttStreamingConfig>,
}
/// Streaming STT configuration (mirrors WhisperSTT::StreamingSTTConfig)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SttStreamingConfig {
    /// Process audio every N ms (default: 3000)
    #[prost(int32, tag = "1")]
    pub step_ms: i32,
    /// Sliding window length in ms (default: 10000)
    #[prost(int32, tag = "2")]
    pub length_ms: i32,
    /// Audio to keep for context (default: 200)
    #[prost(int32, tag = "3")]
    pub keep_ms: i32,
    /// VAD threshold for speech detection (default: 0.6)
    #[prost(float, tag = "4")]
    pub vad_threshold: f32,
    /// High-pass cutoff for noise filtering (default: 100Hz)
    #[prost(float, tag = "5")]
    pub freq_threshold: f32,
    /// Silence duration to trigger finalization (default: 1500)
    #[prost(int32, tag = "6")]
    pub silence_threshold_ms: i32,
    /// Use VAD to detect utterance boundaries (default: true)
    #[prost(bool, optional, tag = "7")]
    pub use_vad_segmentation: ::core::option::Option<bool>,
    /// Force segment break after this duration (default: 30000)
    #[prost(int32, tag = "8")]
    pub max_segment_duration_ms: i32,
}
/// Streaming transcription result (server -> client)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranscriptChunk {
    /// Transcript text (partial or final)
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// True if this chunk is final for the utterance
    #[prost(bool, tag = "2")]
    pub is_final: bool,
    /// Speech detected in current window
    #[prost(bool, tag = "3")]
    pub speech_detected: bool,
    /// Timestamp from start of stream
    #[prost(int64, tag = "4")]
    pub timestamp_ms: i64,
    /// Confidence score (0-1)
    #[prost(float, tag = "5")]
    pub confidence: f32,
}
/// Empty message for requests with no parameters
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
/// Audio input for filtered STT (includes TTS reference info)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredAudioInput {
    /// Raw PCM16 audio chunk (16kHz mono)
    #[prost(bytes = "vec", tag = "1")]
    pub audio: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate (default: 16000)
    #[prost(int32, tag = "2")]
    pub sample_rate: i32,
    /// True when this is the last chunk
    #[prost(bool, tag = "3")]
    pub end_of_stream: bool,
    /// STT streaming config (first chunk only)
    #[prost(message, optional, tag = "4")]
    pub stt_config: ::core::option::Option<SttStreamingConfig>,
    /// Optional metadata for this chunk
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<FilteredInputMetadata>,
}
/// Unified listen request that can carry config or audio
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredListenRequest {
    /// Client session identifier
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// Reset filter state/statistics
    #[prost(bool, tag = "4")]
    pub reset_state: bool,
    #[prost(oneof = "filtered_listen_request::Payload", tags = "2, 3")]
    pub payload: ::core::option::Option<filtered_listen_request::Payload>,
}
/// Nested message and enum types in `FilteredListenRequest`.
pub mod filtered_listen_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Audio chunk with optional metadata
        #[prost(message, tag = "2")]
        Audio(super::FilteredAudioInput),
        /// Configuration update (sent once or mid-stream)
        #[prost(message, tag = "3")]
        Config(super::FilterConfig),
    }
}
/// Metadata for filtered audio input
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredInputMetadata {
    /// If the client knows TTS is playing, include reference audio
    ///
    /// TTS audio samples (for AEC)
    #[prost(bytes = "vec", tag = "1")]
    pub tts_reference_audio: ::prost::alloc::vec::Vec<u8>,
    /// TTS text being spoken (for text match)
    #[prost(string, tag = "2")]
    pub tts_text: ::prost::alloc::string::String,
    /// Whether TTS is currently speaking
    #[prost(bool, tag = "3")]
    pub tts_active: bool,
}
/// Filtered transcription result with speaker labels
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteredTranscriptEvent {
    /// User speech only (agent filtered out)
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Identified speaker ("user_0", "unknown")
    #[prost(string, tag = "2")]
    pub speaker_id: ::prost::alloc::string::String,
    /// Speaker identification confidence (0-1)
    #[prost(float, tag = "3")]
    pub speaker_confidence: f32,
    /// Timestamp from start of stream
    #[prost(int64, tag = "4")]
    pub timestamp_ms: i64,
    /// True if this is a final segment
    #[prost(bool, tag = "5")]
    pub is_final: bool,
    /// Speech detected in this segment
    #[prost(bool, tag = "6")]
    pub speech_detected: bool,
    /// Confidence this is user speech (0-1)
    #[prost(float, tag = "7")]
    pub user_confidence: f32,
    /// Filtering details (for debugging)
    #[prost(message, optional, tag = "10")]
    pub filtering: ::core::option::Option<FilteringDetails>,
}
/// Simplified transcription event for dashflow clients
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TranscriptionEvent {
    /// Client session identifier
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// User speech only (agent filtered)
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    /// Identified speaker ("user_0", "agent", "unknown")
    #[prost(string, tag = "3")]
    pub speaker_id: ::prost::alloc::string::String,
    /// Confidence this is user speech (0-1)
    #[prost(float, tag = "4")]
    pub confidence: f32,
    /// Timestamp from start of session
    #[prost(int64, tag = "5")]
    pub timestamp_ms: i64,
    /// True if this is a final segment
    #[prost(bool, tag = "6")]
    pub is_final: bool,
    /// Speech detected in this segment
    #[prost(bool, tag = "7")]
    pub speech_detected: bool,
    /// Confidence of diarization match (0-1)
    #[prost(float, tag = "8")]
    pub speaker_confidence: f32,
    /// Filtering details for debugging
    #[prost(message, optional, tag = "9")]
    pub filtering: ::core::option::Option<FilteringDetails>,
}
/// Details about what was filtered
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilteringDetails {
    /// Text that was filtered out as agent
    #[prost(string, tag = "1")]
    pub filtered_agent_speech: ::prost::alloc::string::String,
    /// Confidence the filtered text was agent
    #[prost(float, tag = "2")]
    pub agent_confidence: f32,
    /// Text matching similarity score
    #[prost(float, tag = "3")]
    pub text_match_score: f32,
    /// AEC echo suppression ratio
    #[prost(float, tag = "4")]
    pub aec_suppression_ratio: f32,
    /// Whether text matching was applied
    #[prost(bool, tag = "5")]
    pub text_match_active: bool,
    /// Whether AEC was applied
    #[prost(bool, tag = "6")]
    pub aec_active: bool,
    /// Whether speaker ID was applied
    #[prost(bool, tag = "7")]
    pub speaker_id_active: bool,
}
/// Filter configuration
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilterConfig {
    /// Enable text-based filtering
    #[prost(bool, tag = "1")]
    pub enable_text_matching: bool,
    /// Enable acoustic echo cancellation
    #[prost(bool, tag = "2")]
    pub enable_aec: bool,
    /// Enable speaker identification
    #[prost(bool, tag = "3")]
    pub enable_speaker_diarization: bool,
    /// Threshold for agent detection (0-1)
    #[prost(float, tag = "4")]
    pub agent_confidence_threshold: f32,
    /// Weights for combining filter scores (should sum to 1.0)
    ///
    /// Weight for text matching (default: 0.3)
    #[prost(float, tag = "5")]
    pub text_match_weight: f32,
    /// Weight for AEC (default: 0.2)
    #[prost(float, tag = "6")]
    pub aec_weight: f32,
    /// Weight for speaker ID (default: 0.5)
    #[prost(float, tag = "7")]
    pub speaker_id_weight: f32,
    /// Speaker diarization settings
    ///
    /// Cosine similarity threshold (default: 0.6)
    #[prost(float, tag = "8")]
    pub speaker_threshold: f32,
    /// Auto-learn new speakers
    #[prost(bool, tag = "9")]
    pub enable_speaker_learning: bool,
    /// Debug settings
    ///
    /// Enable debug logging
    #[prost(bool, tag = "10")]
    pub debug_logging: bool,
}
/// Filter configuration response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterConfigResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Error message if failed
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Current configuration after update
    #[prost(message, optional, tag = "3")]
    pub current_config: ::core::option::Option<FilterConfig>,
}
/// TTS state response (for polling)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TtsStateResponse {
    /// Whether TTS is currently speaking
    #[prost(bool, tag = "1")]
    pub is_speaking: bool,
    /// Text being spoken (if any)
    #[prost(string, tag = "2")]
    pub current_text: ::prost::alloc::string::String,
    /// When current speech started
    #[prost(int64, tag = "3")]
    pub start_time_ms: i64,
    /// Estimated duration of current speech
    #[prost(float, tag = "4")]
    pub estimated_duration_ms: f32,
    /// Time since speech started
    #[prost(float, tag = "5")]
    pub elapsed_ms: f32,
}
/// TTS state event (for streaming subscription)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TtsStateEvent {
    #[prost(enumeration = "tts_state_event::EventType", tag = "1")]
    pub event_type: i32,
    /// Text being spoken
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    /// When this event occurred
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    /// Duration (for end event)
    #[prost(float, tag = "4")]
    pub duration_ms: f32,
}
/// Nested message and enum types in `TTSStateEvent`.
pub mod tts_state_event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EventType {
        EventUnknown = 0,
        /// TTS started speaking
        EventTtsStart = 1,
        /// TTS finished speaking
        EventTtsEnd = 2,
        /// TTS was interrupted
        EventTtsInterrupted = 3,
    }
    impl EventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EventUnknown => "EVENT_UNKNOWN",
                Self::EventTtsStart => "EVENT_TTS_START",
                Self::EventTtsEnd => "EVENT_TTS_END",
                Self::EventTtsInterrupted => "EVENT_TTS_INTERRUPTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVENT_UNKNOWN" => Some(Self::EventUnknown),
                "EVENT_TTS_START" => Some(Self::EventTtsStart),
                "EVENT_TTS_END" => Some(Self::EventTtsEnd),
                "EVENT_TTS_INTERRUPTED" => Some(Self::EventTtsInterrupted),
                _ => None,
            }
        }
    }
}
/// Register speaker request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterSpeakerRequest {
    /// Unique speaker identifier
    #[prost(string, tag = "1")]
    pub speaker_id: ::prost::alloc::string::String,
    /// Audio samples from this speaker
    #[prost(bytes = "vec", tag = "2")]
    pub audio_samples: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate (default: 16000)
    #[prost(int32, tag = "3")]
    pub sample_rate: i32,
}
/// Register speaker response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterSpeakerResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Assigned speaker ID
    #[prost(string, tag = "2")]
    pub speaker_id: ::prost::alloc::string::String,
    /// Error if failed
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
}
/// Filter statistics
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FilterStatsResponse {
    #[prost(uint64, tag = "1")]
    pub total_utterances: u64,
    #[prost(uint64, tag = "2")]
    pub user_speech_count: u64,
    #[prost(uint64, tag = "3")]
    pub agent_speech_count: u64,
    #[prost(uint64, tag = "4")]
    pub mixed_speech_count: u64,
    #[prost(float, tag = "5")]
    pub avg_user_confidence: f32,
    #[prost(float, tag = "6")]
    pub avg_agent_confidence: f32,
    #[prost(float, tag = "7")]
    pub avg_latency_ms: f32,
    #[prost(float, tag = "8")]
    pub max_latency_ms: f32,
    /// Per-layer stats
    #[prost(uint64, tag = "10")]
    pub text_matches_found: u64,
    #[prost(float, tag = "11")]
    pub avg_text_similarity: f32,
    #[prost(uint64, tag = "12")]
    pub aec_frames_processed: u64,
    #[prost(float, tag = "13")]
    pub avg_erle_db: f32,
    #[prost(uint64, tag = "14")]
    pub speaker_identifications: u64,
    #[prost(float, tag = "15")]
    pub avg_speaker_confidence: f32,
    #[prost(uint32, tag = "16")]
    pub unique_speakers_seen: u32,
}
/// Wake word listening configuration (renamed from WakeWordConfig to avoid C++ collision)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordListenConfig {
    /// Wake words to detect (empty = detect all loaded models)
    #[prost(string, repeated, tag = "1")]
    pub wake_words: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Detection threshold (0.0-1.0, default 0.5)
    #[prost(float, tag = "2")]
    pub threshold: f32,
    /// Refractory period in ms (min time between activations, default 2000)
    #[prost(int32, tag = "3")]
    pub refractory_ms: i32,
    /// Integration with self-speech filter
    #[prost(bool, tag = "4")]
    pub enable_self_speech_filter: bool,
    /// Play activation sound on detection
    #[prost(bool, tag = "5")]
    pub play_activation_sound: bool,
    /// Custom activation sound path (empty = default chime)
    #[prost(string, tag = "6")]
    pub activation_sound_path: ::prost::alloc::string::String,
}
/// Wake word detection event (renamed from WakeWordEvent to avoid C++ collision)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordDetectionEvent {
    /// Name of detected wake word (e.g., "hey_voice", "alexa")
    #[prost(string, tag = "1")]
    pub wake_word: ::prost::alloc::string::String,
    /// Detection confidence (0.0-1.0)
    #[prost(float, tag = "2")]
    pub confidence: f32,
    /// Timestamp in ms since stream started
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    /// Detection latency from audio end to callback
    #[prost(int64, tag = "4")]
    pub latency_ms: i64,
    /// Whether activation sound was played
    #[prost(bool, tag = "5")]
    pub activation_sound_played: bool,
}
/// Enable/disable request
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WakeWordEnabledRequest {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// Enable/disable response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordEnabledResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(bool, tag = "2")]
    pub enabled: bool,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
}
/// Stop listening response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordStopResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Wake word status response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordStatusResponse {
    /// Current state
    #[prost(bool, tag = "1")]
    pub is_listening: bool,
    #[prost(bool, tag = "2")]
    pub is_enabled: bool,
    /// TTS active (detection paused)
    #[prost(bool, tag = "3")]
    pub is_speaking: bool,
    /// Loaded wake word models
    #[prost(string, repeated, tag = "4")]
    pub loaded_models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Current detection threshold
    #[prost(float, tag = "5")]
    pub threshold: f32,
    /// Statistics
    #[prost(message, optional, tag = "6")]
    pub stats: ::core::option::Option<WakeWordStats>,
}
/// Wake word statistics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordStats {
    #[prost(uint64, tag = "1")]
    pub chunks_processed: u64,
    #[prost(uint64, tag = "2")]
    pub total_detections: u64,
    /// Blocked by self-speech filter
    #[prost(uint64, tag = "3")]
    pub false_accepts_filtered: u64,
    #[prost(float, tag = "4")]
    pub avg_inference_ms: f32,
    #[prost(float, tag = "5")]
    pub uptime_seconds: f32,
    /// Per-model statistics
    #[prost(message, repeated, tag = "6")]
    pub model_stats: ::prost::alloc::vec::Vec<WakeWordModelStats>,
}
/// Per-model statistics
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordModelStats {
    #[prost(string, tag = "1")]
    pub model_name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub detections: u64,
    #[prost(float, tag = "3")]
    pub avg_confidence: f32,
}
/// List of available wake word models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordModelList {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<WakeWordModelInfo>,
}
/// Wake word model information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordModelInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_loaded: bool,
    /// True if custom-trained model
    #[prost(bool, tag = "4")]
    pub is_custom: bool,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
}
/// Test detection request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordTestRequest {
    /// Raw PCM16 audio (16kHz mono)
    #[prost(bytes = "vec", tag = "1")]
    pub audio: ::prost::alloc::vec::Vec<u8>,
    /// Sample rate (default 16000)
    #[prost(int32, tag = "2")]
    pub sample_rate: i32,
    /// Wake word to test (empty = test all loaded models)
    #[prost(string, tag = "3")]
    pub wake_word: ::prost::alloc::string::String,
}
/// Test detection response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordTestResponse {
    #[prost(bool, tag = "1")]
    pub detected: bool,
    #[prost(string, tag = "2")]
    pub wake_word: ::prost::alloc::string::String,
    #[prost(float, tag = "3")]
    pub confidence: f32,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    /// All model scores
    #[prost(message, repeated, tag = "5")]
    pub scores: ::prost::alloc::vec::Vec<WakeWordScore>,
}
/// Score for a specific wake word model
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WakeWordScore {
    #[prost(string, tag = "1")]
    pub wake_word: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub score: f32,
}
/// Text summarization request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizeTextRequest {
    /// Text to summarize
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    /// Summarization mode
    #[prost(enumeration = "SummarizationMode", tag = "2")]
    pub mode: i32,
    /// Source language (for cross-lingual)
    #[prost(string, tag = "3")]
    pub source_language: ::prost::alloc::string::String,
    /// Output summary language (optional)
    #[prost(string, tag = "4")]
    pub target_language: ::prost::alloc::string::String,
    /// Max output tokens (default: 150)
    #[prost(int32, tag = "5")]
    pub max_tokens: i32,
}
/// Summarization response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizeResponse {
    /// Summary text
    #[prost(string, tag = "1")]
    pub summary: ::prost::alloc::string::String,
    /// Processing time in ms
    #[prost(int64, tag = "2")]
    pub latency_ms: i64,
    /// Detected/specified source language
    #[prost(string, tag = "3")]
    pub source_language: ::prost::alloc::string::String,
    /// Input tokens processed
    #[prost(int32, tag = "4")]
    pub input_token_count: i32,
    /// Output tokens generated
    #[prost(int32, tag = "5")]
    pub output_token_count: i32,
}
/// Live summary event (for streaming mode)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummaryEvent {
    /// Summary text
    #[prost(string, tag = "1")]
    pub summary: ::prost::alloc::string::String,
    /// When summary was generated
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    /// "time", "length", "silence", "manual"
    #[prost(string, tag = "3")]
    pub trigger_reason: ::prost::alloc::string::String,
    /// Words in source transcript
    #[prost(int32, tag = "4")]
    pub transcript_words: i32,
    /// Processing latency
    #[prost(int64, tag = "5")]
    pub latency_ms: i64,
}
/// Summarization status response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationStatusResponse {
    /// Whether Qwen3 model is loaded
    #[prost(bool, tag = "1")]
    pub model_loaded: bool,
    /// Path to loaded model
    #[prost(string, tag = "2")]
    pub model_path: ::prost::alloc::string::String,
    /// Model memory usage
    #[prost(int64, tag = "3")]
    pub memory_usage_bytes: i64,
    /// Whether GPU (Metal) is enabled
    #[prost(bool, tag = "4")]
    pub gpu_enabled: bool,
    /// Model context window size
    #[prost(int32, tag = "5")]
    pub context_size: i32,
    /// Performance metrics
    #[prost(message, optional, tag = "6")]
    pub metrics: ::core::option::Option<SummarizationMetrics>,
}
/// Summarization performance metrics
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummarizationMetrics {
    #[prost(uint64, tag = "1")]
    pub total_requests: u64,
    #[prost(uint64, tag = "2")]
    pub successful_requests: u64,
    #[prost(uint64, tag = "3")]
    pub failed_requests: u64,
    #[prost(float, tag = "4")]
    pub avg_latency_ms: f32,
    #[prost(uint64, tag = "5")]
    pub total_tokens_generated: u64,
    #[prost(float, tag = "6")]
    pub tokens_per_second: f32,
}
/// Summary trigger configuration for LiveSummarize
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummaryTriggerConfig {
    #[prost(enumeration = "summary_trigger_config::TriggerType", tag = "1")]
    pub r#type: i32,
    /// For TIME: interval in ms (default: 60000)
    #[prost(int32, tag = "2")]
    pub interval_ms: i32,
    /// For LENGTH: word count threshold (default: 500)
    #[prost(int32, tag = "3")]
    pub word_threshold: i32,
    /// For SILENCE: silence duration in ms (default: 5000)
    #[prost(int32, tag = "4")]
    pub silence_ms: i32,
    /// Summarization mode for triggered summaries
    #[prost(enumeration = "SummarizationMode", tag = "5")]
    pub mode: i32,
}
/// Nested message and enum types in `SummaryTriggerConfig`.
pub mod summary_trigger_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TriggerType {
        /// Summarize at time intervals
        TriggerTime = 0,
        /// Summarize when word count threshold reached
        TriggerLength = 1,
        /// Summarize after silence detected
        TriggerSilence = 2,
        /// Only summarize on explicit request
        TriggerManual = 3,
    }
    impl TriggerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TriggerTime => "TRIGGER_TIME",
                Self::TriggerLength => "TRIGGER_LENGTH",
                Self::TriggerSilence => "TRIGGER_SILENCE",
                Self::TriggerManual => "TRIGGER_MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRIGGER_TIME" => Some(Self::TriggerTime),
                "TRIGGER_LENGTH" => Some(Self::TriggerLength),
                "TRIGGER_SILENCE" => Some(Self::TriggerSilence),
                "TRIGGER_MANUAL" => Some(Self::TriggerManual),
                _ => None,
            }
        }
    }
}
/// Audio format specification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudioFormat {
    FormatUnspecified = 0,
    /// WAV (PCM 16-bit)
    FormatWav = 1,
    /// Raw PCM 16-bit
    FormatPcm16bit = 2,
    /// Raw PCM float32
    FormatPcmFloat = 3,
}
impl AudioFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FormatUnspecified => "FORMAT_UNSPECIFIED",
            Self::FormatWav => "FORMAT_WAV",
            Self::FormatPcm16bit => "FORMAT_PCM_16BIT",
            Self::FormatPcmFloat => "FORMAT_PCM_FLOAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FORMAT_UNSPECIFIED" => Some(Self::FormatUnspecified),
            "FORMAT_WAV" => Some(Self::FormatWav),
            "FORMAT_PCM_16BIT" => Some(Self::FormatPcm16bit),
            "FORMAT_PCM_FLOAT" => Some(Self::FormatPcmFloat),
            _ => None,
        }
    }
}
/// Summarization modes for different use cases
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SummarizationMode {
    /// 1 sentence, <30 words
    ModeBrief = 0,
    /// 2-3 sentences, key points
    ModeStandard = 1,
    /// Bullet points, all topics
    ModeDetailed = 2,
    /// Only actionable items
    ModeActionItems = 3,
    /// Tool call descriptions
    ModeToolCall = 4,
}
impl SummarizationMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ModeBrief => "MODE_BRIEF",
            Self::ModeStandard => "MODE_STANDARD",
            Self::ModeDetailed => "MODE_DETAILED",
            Self::ModeActionItems => "MODE_ACTION_ITEMS",
            Self::ModeToolCall => "MODE_TOOL_CALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODE_BRIEF" => Some(Self::ModeBrief),
            "MODE_STANDARD" => Some(Self::ModeStandard),
            "MODE_DETAILED" => Some(Self::ModeDetailed),
            "MODE_ACTION_ITEMS" => Some(Self::ModeActionItems),
            "MODE_TOOL_CALL" => Some(Self::ModeToolCall),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod tts_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TtsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TtsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TtsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TtsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TtsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Unary synthesis - send text, receive complete audio
        pub async fn synthesize(
            &mut self,
            request: impl tonic::IntoRequest<super::SynthesizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SynthesizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TTSService/Synthesize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.TTSService", "Synthesize"));
            self.inner.unary(req, path, codec).await
        }
        /// Streaming synthesis - send text, receive audio chunks as they're generated
        pub async fn stream_synthesize(
            &mut self,
            request: impl tonic::IntoRequest<super::SynthesizeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AudioChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TTSService/StreamSynthesize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.TTSService", "StreamSynthesize"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Bidirectional streaming - for real-time conversation
        pub async fn stream_tts(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::TtsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AudioChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TTSService/StreamTTS",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.TTSService", "StreamTTS"));
            self.inner.streaming(req, path, codec).await
        }
        /// Health check
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::StatusRequest>,
        ) -> std::result::Result<tonic::Response<super::StatusResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TTSService/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.TTSService", "GetStatus"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod stt_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SttServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SttServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SttServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SttServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SttServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Unary transcription - send raw audio (PCM16), receive full transcript
        pub async fn transcribe(
            &mut self,
            request: impl tonic::IntoRequest<super::TranscribeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TranscribeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.STTService/Transcribe",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.STTService", "Transcribe"));
            self.inner.unary(req, path, codec).await
        }
        /// Bidirectional streaming transcription - stream audio chunks and receive transcripts
        pub async fn stream_transcribe(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::AudioInput>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TranscriptChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.STTService/StreamTranscribe",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.STTService", "StreamTranscribe"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod translation_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TranslationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TranslationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TranslationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TranslationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TranslationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Translate text
        pub async fn translate(
            &mut self,
            request: impl tonic::IntoRequest<super::TranslateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TranslateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TranslationService/Translate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.TranslationService", "Translate"));
            self.inner.unary(req, path, codec).await
        }
        /// Translate and synthesize (combined endpoint)
        pub async fn translate_and_synthesize(
            &mut self,
            request: impl tonic::IntoRequest<super::TranslateAndSynthesizeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AudioChunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.TranslationService/TranslateAndSynthesize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("voice.TranslationService", "TranslateAndSynthesize"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod filtered_stt_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct FilteredSttServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FilteredSttServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FilteredSttServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FilteredSttServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FilteredSttServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Streaming transcription with self-speech filtering
        /// Filters out agent voice and returns only user speech
        pub async fn stream_filtered_transcribe(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::FilteredAudioInput,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FilteredTranscriptEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/StreamFilteredTranscribe",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "voice.FilteredSTTService",
                        "StreamFilteredTranscribe",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Bidirectional streaming optimized for dashflow clients
        /// Allows mixed control/audio messages and streams filtered transcription events
        pub async fn start_filtered_listen(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::FilteredListenRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TranscriptionEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/StartFilteredListen",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("voice.FilteredSTTService", "StartFilteredListen"),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Configure the filter settings
        pub async fn configure_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::FilterConfig>,
        ) -> std::result::Result<
            tonic::Response<super::FilterConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/ConfigureFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.FilteredSTTService", "ConfigureFilter"));
            self.inner.unary(req, path, codec).await
        }
        /// Get current TTS state (for debugging/monitoring)
        pub async fn get_tts_state(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::TtsStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/GetTTSState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.FilteredSTTService", "GetTTSState"));
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to TTS state changes
        pub async fn subscribe_tts_state(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TtsStateEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/SubscribeTTSState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("voice.FilteredSTTService", "SubscribeTTSState"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Register a speaker for identification
        pub async fn register_speaker(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterSpeakerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterSpeakerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/RegisterSpeaker",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.FilteredSTTService", "RegisterSpeaker"));
            self.inner.unary(req, path, codec).await
        }
        /// Get filter statistics
        pub async fn get_filter_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::FilterStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.FilteredSTTService/GetFilterStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.FilteredSTTService", "GetFilterStats"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod wake_word_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WakeWordServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WakeWordServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WakeWordServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WakeWordServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WakeWordServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Start listening for wake words (streaming events)
        /// Returns a stream of detection events when wake words are detected
        pub async fn start_listening(
            &mut self,
            request: impl tonic::IntoRequest<super::WakeWordListenConfig>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WakeWordDetectionEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/StartListening",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "StartListening"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Stop listening for wake words
        pub async fn stop_listening(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::WakeWordStopResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/StopListening",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "StopListening"));
            self.inner.unary(req, path, codec).await
        }
        /// Enable/disable wake word detection
        pub async fn set_enabled(
            &mut self,
            request: impl tonic::IntoRequest<super::WakeWordEnabledRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WakeWordEnabledResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/SetEnabled",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "SetEnabled"));
            self.inner.unary(req, path, codec).await
        }
        /// Get current status and statistics
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::WakeWordStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "GetStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// List available wake word models
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::WakeWordModelList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/ListModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "ListModels"));
            self.inner.unary(req, path, codec).await
        }
        /// Test wake word detection with audio sample
        pub async fn test_detection(
            &mut self,
            request: impl tonic::IntoRequest<super::WakeWordTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WakeWordTestResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.WakeWordService/TestDetection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.WakeWordService", "TestDetection"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod summarization_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SummarizationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SummarizationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SummarizationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SummarizationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SummarizationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Summarize text directly
        pub async fn summarize(
            &mut self,
            request: impl tonic::IntoRequest<super::SummarizeTextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SummarizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.SummarizationService/Summarize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.SummarizationService", "Summarize"));
            self.inner.unary(req, path, codec).await
        }
        /// Streaming: accumulate audio, return summary
        pub async fn stream_summarize(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::AudioInput>,
        ) -> std::result::Result<
            tonic::Response<super::SummarizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.SummarizationService/StreamSummarize",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("voice.SummarizationService", "StreamSummarize"),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        /// Live mode: return summaries as they become available (triggered by time/length/silence)
        pub async fn live_summarize(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::AudioInput>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SummaryEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.SummarizationService/LiveSummarize",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("voice.SummarizationService", "LiveSummarize"));
            self.inner.streaming(req, path, codec).await
        }
        /// Get current summarization model status
        pub async fn get_summarization_status(
            &mut self,
            request: impl tonic::IntoRequest<super::Empty>,
        ) -> std::result::Result<
            tonic::Response<super::SummarizationStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/voice.SummarizationService/GetSummarizationStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "voice.SummarizationService",
                        "GetSummarizationStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
