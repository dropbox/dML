diff --git a/aten/src/ATen/mps/MPSHooks.mm b/aten/src/ATen/mps/MPSHooks.mm
index 9965b29a..0919548f 100644
--- a/aten/src/ATen/mps/MPSHooks.mm
+++ b/aten/src/ATen/mps/MPSHooks.mm
@@ -104,15 +104,22 @@ void* MPSHooks::getCommandBuffer() const {
   // can invalidate encoders while another thread is using them inside dispatch_sync.
   // Unlike encodeSignalEvent() which can use dispatch_async, we need dispatch_sync
   // here because we must return the command buffer pointer synchronously.
+  //
+  // FIX (Bug #045): When re-entrant, skip endKernelCoalescing to avoid UAF.
+  // The outer dispatch block may still be using the encoder.
   __block void* result = nullptr;
+  __block bool isReentrant = (dispatch_get_specific(at::mps::getMPSStreamQueueSpecificKey()) == static_cast<void*>(stream));
   dispatch_block_t dispatch_block = ^() {
     @autoreleasepool {
       // Release pending computeCommandEncoder, as extensions is likely to allocate new one
-      stream->endKernelCoalescing();
+      // FIX (Bug #045): Only end encoding if not re-entrant
+      if (!isReentrant) {
+        stream->endKernelCoalescing();
+      }
       result = stream->commandBuffer();
     }
   };
-  if (dispatch_get_specific(at::mps::getMPSStreamQueueSpecificKey()) == static_cast<void*>(stream)) {
+  if (isReentrant) {
     // Already on this stream's queue - execute directly
     dispatch_block();
   } else {
diff --git a/aten/src/ATen/mps/MPSStream.mm b/aten/src/ATen/mps/MPSStream.mm
index a8f6fc48..c946fba1 100644
--- a/aten/src/ATen/mps/MPSStream.mm
+++ b/aten/src/ATen/mps/MPSStream.mm
@@ -165,21 +165,30 @@ void MPSStream::encodeSignalEvent(id<MTLSharedEvent> event, uint64_t value) {
   // We use dispatch_async for off-queue callers to avoid deadlock: the allocator
   // holds pool_mutex when calling this, and dispatch_sync would block if a thread
   // on this queue is waiting for pool_mutex.
+  //
+  // FIX (Bug #045): When re-entrant (on this stream's queue), do NOT call
+  // endKernelCoalescing - the outer block may still be using the encoder.
+  // Event signals are encoded on the command buffer, not the encoder, so
+  // we can safely skip ending the encoder and just encode the event.
   __block id<MTLSharedEvent> eventCopy = [event retain];
   __block uint64_t valueCopy = value;
   __block MPSStream* streamPtr = this;
+  __block bool isReentrant = (dispatch_get_specific(getMPSStreamQueueSpecificKey()) == static_cast<void*>(this));
 
   dispatch_block_t dispatch_block = ^() {
     @autoreleasepool {
       std::lock_guard<std::recursive_mutex> lock(streamPtr->_streamMutex);
-      streamPtr->endKernelCoalescing();
+      // FIX (Bug #045): Only end encoding if not re-entrant
+      if (!isReentrant) {
+        streamPtr->endKernelCoalescing();
+      }
       id<MTLCommandBuffer> cmdBuffer = streamPtr->commandBuffer();
       [cmdBuffer encodeSignalEvent:eventCopy value:valueCopy];
       [eventCopy release];
     }
   };
 
-  if (dispatch_get_specific(getMPSStreamQueueSpecificKey()) == static_cast<void*>(this)) {
+  if (isReentrant) {
     // Already on this stream's queue - execute directly
     dispatch_block();
   } else {
@@ -191,21 +200,26 @@ void MPSStream::encodeSignalEvent(id<MTLSharedEvent> event, uint64_t value) {
 void MPSStream::encodeWaitForEvent(id<MTLSharedEvent> event, uint64_t value) {
   TORCH_INTERNAL_ASSERT(event);
   // 32.274 fix: Same serialization pattern as encodeSignalEvent.
+  // FIX (Bug #045): Same re-entrant safety fix as encodeSignalEvent.
   __block id<MTLSharedEvent> eventCopy = [event retain];
   __block uint64_t valueCopy = value;
   __block MPSStream* streamPtr = this;
+  __block bool isReentrant = (dispatch_get_specific(getMPSStreamQueueSpecificKey()) == static_cast<void*>(this));
 
   dispatch_block_t dispatch_block = ^() {
     @autoreleasepool {
       std::lock_guard<std::recursive_mutex> lock(streamPtr->_streamMutex);
-      streamPtr->endKernelCoalescing();
+      // FIX (Bug #045): Only end encoding if not re-entrant
+      if (!isReentrant) {
+        streamPtr->endKernelCoalescing();
+      }
       id<MTLCommandBuffer> cmdBuffer = streamPtr->commandBuffer();
       [cmdBuffer encodeWaitForEvent:eventCopy value:valueCopy];
       [eventCopy release];
     }
   };
 
-  if (dispatch_get_specific(getMPSStreamQueueSpecificKey()) == static_cast<void*>(this)) {
+  if (isReentrant) {
     dispatch_block();
   } else {
     dispatch_async(queue(), dispatch_block);
@@ -220,19 +234,33 @@ void MPSStream::synchronize(SyncType syncType) {
   // This caused a race: synchronize() could end the encoder while a dispatch block was
   // using it, resulting in use-after-free (PAC failure on encoder's isa pointer).
   //
-  // Fix: Route endKernelCoalescing through dispatch_sync to serialize with other blocks.
-  // If already on this queue (re-entrant call), execute directly to avoid deadlock.
-
-  dispatch_block_t end_encoding_block = ^() {
-    std::lock_guard<std::recursive_mutex> lock(_streamMutex);
-    endKernelCoalescing();
-  };
+  // FIX (Bug #045 - re-entrant synchronize still causes UAF):
+  // Bug #044's fix had a flaw: when re-entrant (called from within a dispatch block on
+  // this stream's queue), it executed endKernelCoalescing() directly. This can still
+  // cause UAF if the outer dispatch block is using the encoder. Example crash scenario:
+  //   1. Thread A runs dispatch block on stream queue, gets encoder via commandEncoder()
+  //   2. Operation inside block triggers synchronize() on same stream (e.g., memory ops)
+  //   3. Re-entrant check passes, endKernelCoalescing() called directly
+  //   4. Encoder freed while outer block still using it -> PAC failure crash
+  //
+  // Fix: When re-entrant, SKIP endKernelCoalescing entirely. The encoder is likely in use
+  // by the outer dispatch block. It will be ended by:
+  //   a) The next non-re-entrant synchronize() call from outside the queue
+  //   b) Another dispatch block's endKernelCoalescing (fill, copy, executeMPSGraph, etc.)
+  //   c) Stream destruction
+  // This trades potential encoder lifetime extension for safety against UAF.
 
   if (dispatch_get_specific(getMPSStreamQueueSpecificKey()) == static_cast<void*>(this)) {
-    // Already on this stream's queue - execute directly (re-entrant safe)
-    end_encoding_block();
+    // Already on this stream's queue - re-entrant call.
+    // FIX (Bug #045): Do NOT end encoding - outer block may still be using the encoder.
+    // Calling dispatch_sync here would deadlock (serial queue waiting for itself).
+    // Skip endKernelCoalescing; the encoder will be ended by a subsequent operation.
   } else {
     // Off-queue: dispatch_sync to serialize with encoder-using blocks
+    dispatch_block_t end_encoding_block = ^() {
+      std::lock_guard<std::recursive_mutex> lock(_streamMutex);
+      endKernelCoalescing();
+    };
     dispatch_sync(_serialQueue, end_encoding_block);
   }
 
