diff --git a/aten/src/ATen/mps/MPSStream.h b/aten/src/ATen/mps/MPSStream.h
index 7f096ae9..683f07e3 100644
--- a/aten/src/ATen/mps/MPSStream.h
+++ b/aten/src/ATen/mps/MPSStream.h
@@ -124,8 +124,10 @@ class TORCH_API MPSStream {
   MPSGraphExecutionDescriptor* _executionDescriptor = nil;
   MPSGraphCompilationDescriptor* _compilationDescriptor = nil;
   dispatch_queue_t _serialQueue = nullptr;
-  // CommitAndContinue is enabled by default
-  bool _enableCommitAndContinue = true;
+  // CommitAndContinue is disabled for thread safety
+  bool _enableCommitAndContinue = false;
+  // Mutex to serialize all operations on this stream from multiple threads
+  mutable std::recursive_mutex _streamMutex;
 
   // use synchronize() to access any of these commit functions outside MPSStream
   void commit();
diff --git a/aten/src/ATen/mps/MPSStream.mm b/aten/src/ATen/mps/MPSStream.mm
index eb6d8d89..2a3a41e7 100644
--- a/aten/src/ATen/mps/MPSStream.mm
+++ b/aten/src/ATen/mps/MPSStream.mm
@@ -12,6 +12,11 @@
 
 namespace at::mps {
 
+// Global mutex to serialize MPSGraph encoding across all threads
+// This is needed because Apple's MPSGraph may have internal global state that
+// is not thread-safe when encoding to different command buffers simultaneously
+static std::mutex g_mpsgraph_encode_mutex;
+
 //-----------------------------------------------------------------
 //  MPSStream
 //-----------------------------------------------------------------
@@ -23,10 +28,11 @@ MPSStream::MPSStream(Stream stream) : _stream(stream) {
   _executionDescriptor = [MPSGraphExecutionDescriptor new];
   _compilationDescriptor = [MPSGraphCompilationDescriptor new];
 
-  // disable commitAndContinue if Signpost tracing is enabled
-  if (getMPSProfiler().isSignpostTracingEnabled() || getMPSProfiler().isCaptureEnabled()) {
-    _enableCommitAndContinue = false;
-  }
+  // WORKAROUND: Disable commitAndContinue for thread safety
+  // When multiple streams are used concurrently, commitAndContinue can cause
+  // Metal command buffer state corruption. Disabling it ensures clean commit/wait
+  // semantics at the cost of some pipelining efficiency.
+  _enableCommitAndContinue = false;
   _executionDescriptor.enableCommitAndContinue = _enableCommitAndContinue;
 
   // Choose level which optimizes for GPU
@@ -50,6 +56,7 @@ MPSStream::~MPSStream() {
 }
 
 MPSCommandBuffer* MPSStream::commandBuffer() {
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   if (!_commandBuffer) {
     _commandBuffer = [MPSCommandBuffer commandBufferFromCommandQueue:_commandQueue].retain;
   }
@@ -62,6 +69,7 @@ id<MTLDevice> MPSStream::device() const {
 }
 
 id<MTLComputeCommandEncoder> MPSStream::commandEncoder() {
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   if (!_commandEncoder) {
     _commandEncoder = [commandBuffer() computeCommandEncoder].retain;
   }
@@ -70,6 +78,7 @@ id<MTLComputeCommandEncoder> MPSStream::commandEncoder() {
 }
 
 void MPSStream::synchronize(SyncType syncType) {
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   endKernelCoalescing();
   switch (syncType) {
     case SyncType::NONE:
@@ -148,6 +157,7 @@ void MPSStream::flush() {
 }
 
 void MPSStream::addCompletedHandler(MTLCommandBufferHandler block) {
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   dispatch_sync(_serialQueue, ^() {
     @autoreleasepool {
       [commandBuffer() addCompletedHandler:block];
@@ -159,6 +169,7 @@ void MPSStream::fill(id<MTLBuffer> buffer, uint8_t value, size_t length, size_t
   if (length == 0) {
     return;
   }
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   dispatch_sync(_serialQueue, ^() {
     @autoreleasepool {
       endKernelCoalescing();
@@ -189,6 +200,7 @@ void MPSStream::copy(id<MTLBuffer> srcBuffer,
                      size_t dstOffset,
                      uint64_t profileId,
                      SyncType syncType) {
+  std::lock_guard<std::recursive_mutex> lock(_streamMutex);
   dispatch_sync(_serialQueue, ^() {
     @autoreleasepool {
       endKernelCoalescing();
@@ -242,6 +254,9 @@ void MPSStream::executeMPSGraph(MPSGraph* mpsGraph, NSDictionary* feeds, NSDicti
   auto& profiler = getMPSProfiler();
   const bool isGraphProfilingEnabled = profiler.isOperationProfilingEnabled();
 
+  // Acquire per-stream mutex to serialize operations on this stream
+  std::lock_guard<std::recursive_mutex> stream_lock(_streamMutex);
+
   // Acquire global mutex to serialize MPSGraph encoding across all streams
   // This is needed because Apple's MPSGraph may have internal global state that
   // is not thread-safe when encoding to different command buffers simultaneously
@@ -284,11 +299,6 @@ void MPSStream::executeMPSGraph(MPSGraph* mpsGraph, NSDictionary* feeds, NSDicti
 // Global flag to track if pool is still alive (for safe TLS destruction)
 static std::atomic<bool> g_pool_alive{false};
 
-// Global mutex to serialize MPSGraph encoding across all threads
-// This is needed because Apple's MPSGraph/Metal may have threading limitations
-// when encoding to different command buffers simultaneously
-static std::mutex g_mpsgraph_encode_mutex;
-
 // TLS RAII wrapper that returns stream slot to freelist on thread exit
 struct ThreadStreamSlot {
   size_t slot_index = 0;  // 0 = default stream (not recyclable), >0 = worker slot
