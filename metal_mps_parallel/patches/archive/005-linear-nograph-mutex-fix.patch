diff --git a/aten/src/ATen/mps/MPSAllocator.mm b/aten/src/ATen/mps/MPSAllocator.mm
index c8b3453f..5de0ca26 100644
--- a/aten/src/ATen/mps/MPSAllocator.mm
+++ b/aten/src/ATen/mps/MPSAllocator.mm
@@ -366,7 +366,9 @@ bool MPSHeapAllocatorImpl::release_buffer(BufferBlock* buffer_block, bool remove
     if (retainCount > 1) {
       pool.heaps_pending_update.insert(heap_block);
       m_mutex.unlock();
-      m_stream->addCompletedHandler(^(id<MTLCommandBuffer>) {
+      // Use getCurrentMPSStream() to add handler to the calling thread's stream
+      // This prevents race conditions when multiple threads use different streams
+      getCurrentMPSStream()->addCompletedHandler(^(id<MTLCommandBuffer>) {
         std::lock_guard<std::recursive_mutex> lock(m_mutex);
         // check if the heap block still exists
         if (pool.heaps_pending_update.find(heap_block) != pool.heaps_pending_update.end()) {
@@ -659,8 +661,9 @@ void MPSHeapAllocatorImpl::free(void* ptr) {
     }
   }
   // we sync the scalar pool manually with completion handler at the time buffer is
-  // freed when the MPSScalar instance goes our of scope
-  m_stream->addCompletedHandler(^(id<MTLCommandBuffer>) {
+  // freed when the MPSScalar instance goes out of scope
+  // Use getCurrentMPSStream() to add handler to the calling thread's stream
+  getCurrentMPSStream()->addCompletedHandler(^(id<MTLCommandBuffer>) {
     std::lock_guard<std::recursive_mutex> lock(m_mutex);
     free_buffer(buffer_block);
   });
diff --git a/aten/src/ATen/mps/MPSGuardImpl.h b/aten/src/ATen/mps/MPSGuardImpl.h
index 008a8d57..bfcf213a 100644
--- a/aten/src/ATen/mps/MPSGuardImpl.h
+++ b/aten/src/ATen/mps/MPSGuardImpl.h
@@ -68,21 +68,38 @@ struct TORCH_API MPSGuardImpl final
   }
 
   Stream getStream(Device d) const override {
-    return Stream(Stream::DEFAULT, Device(c10::DeviceType::MPS, 0));
+    // Return the thread-local current stream (or default if not set)
+    MPSStream* current = getCurrentMPSStream();
+    return current->unwrap();
   }
 
   Stream getNewStream(Device, int priority = 0) const override {
     (void)priority;
-    return Stream(Stream::DEFAULT, Device(c10::DeviceType::MPS, 0));
+    // Acquire a stream from the pool for parallel execution
+    MPSStream* stream = getStreamFromPool();
+    return stream->unwrap();
   }
 
   Stream getDefaultStream(Device d) const override {
-    return Stream(Stream::DEFAULT, Device(c10::DeviceType::MPS, 0));
+    // Return stream 0 (the default stream)
+    MPSStream* defaultStream = getDefaultMPSStream();
+    return defaultStream->unwrap();
   }
 
   // NB: These do NOT set the current device
   Stream exchangeStream(Stream s) const override {
-    return Stream(Stream::DEFAULT, Device(c10::DeviceType::MPS, 0));
+    // Get the current stream before setting new one
+    MPSStream* prev = getCurrentMPSStream();
+    Stream prevStream = prev->unwrap();
+
+    // Set the new stream as current for this thread
+    // Note: We need to map from Stream to MPSStream*
+    // For now, if the stream ID matches, use it from pool
+    MPSStream* newStream = MPSStreamPool::instance().getStream(
+        static_cast<size_t>(s.id()));
+    setCurrentMPSStream(newStream);
+
+    return prevStream;
   }
   DeviceIndex deviceCount() const noexcept override {
     if (at::hasMPS()) {
diff --git a/aten/src/ATen/mps/MPSGuardImpl.mm b/aten/src/ATen/mps/MPSGuardImpl.mm
index a267b40f..873c8032 100644
--- a/aten/src/ATen/mps/MPSGuardImpl.mm
+++ b/aten/src/ATen/mps/MPSGuardImpl.mm
@@ -63,7 +63,8 @@ double MPSGuardImpl::elapsedTime(void* event1, void* event2, const DeviceIndex d
 }
 
 void MPSGuardImpl::synchronizeDevice(const DeviceIndex device_index) const {
-  at::mps::getDefaultMPSStream()->synchronize(SyncType::COMMIT_AND_WAIT);
+  // THREAD-SAFETY FIX: Use current thread's stream for proper parallel execution
+  at::mps::getCurrentMPSStream()->synchronize(SyncType::COMMIT_AND_WAIT);
 }
 
 } // namespace at::mps
diff --git a/aten/src/ATen/mps/MPSHooks.mm b/aten/src/ATen/mps/MPSHooks.mm
index 34fbd31a..82ab3189 100644
--- a/aten/src/ATen/mps/MPSHooks.mm
+++ b/aten/src/ATen/mps/MPSHooks.mm
@@ -62,11 +62,14 @@ Generator MPSHooks::getNewGenerator([[maybe_unused]] DeviceIndex device_index) c
 }
 
 void MPSHooks::deviceSynchronize() const {
-  at::mps::getDefaultMPSStream()->synchronize(SyncType::COMMIT_AND_WAIT);
+  // THREAD-SAFETY FIX: Use current thread's stream instead of always default stream
+  // This ensures each thread synchronizes its own stream when calling torch.mps.synchronize()
+  at::mps::getCurrentMPSStream()->synchronize(SyncType::COMMIT_AND_WAIT);
 }
 
 void MPSHooks::commitStream() const {
-  at::mps::getDefaultMPSStream()->synchronize(SyncType::COMMIT);
+  // THREAD-SAFETY FIX: Use current thread's stream for proper parallel execution
+  at::mps::getCurrentMPSStream()->synchronize(SyncType::COMMIT);
 }
 
 void* MPSHooks::getCommandBuffer() const {
diff --git a/aten/src/ATen/mps/MPSProfiler.mm b/aten/src/ATen/mps/MPSProfiler.mm
index a91574c5..fab66bc6 100644
--- a/aten/src/ATen/mps/MPSProfiler.mm
+++ b/aten/src/ATen/mps/MPSProfiler.mm
@@ -432,9 +432,10 @@ void MPSProfiler::addProfilerScheduledHandler(BaseInfo& info) {
   const SignpostTypes signpostType = getSignpostType(info.type);
   const os_signpost_id_t intervalSignpostId = info.intervalSignpostId;
 
-  auto m_stream = getDefaultMPSStream();
-  // NOTE: the following block isn't thread-safe
-  [m_stream->commandBuffer() addScheduledHandler:^(id<MTLCommandBuffer> cb) {
+  // Use getCurrentMPSStream() to add handler to the calling thread's stream
+  // This ensures thread-safe profiling when using the stream pool
+  auto current_stream = getCurrentMPSStream();
+  [current_stream->commandBuffer() addScheduledHandler:^(id<MTLCommandBuffer> cb) {
     // begin the interval once scheduling has completed (if INCLUDE_SCHEDULE_INTERVAL flag is disabled)
     beginSignpostInterval(signpostType, intervalSignpostId, info.toString());
     info.completed = false;
@@ -471,9 +472,10 @@ void MPSProfiler::addProfilerCompletedHandler(BaseInfo& info, SyncType syncType)
   info.eventSignpostId = 0;
   hasPendingCompletionHandlers = true;
 
-  auto m_stream = getDefaultMPSStream();
-  // NOTE: the following block isn't thread-safe
-  [m_stream->commandBuffer() addCompletedHandler:^(id<MTLCommandBuffer> cb) {
+  // Use getCurrentMPSStream() to add handler to the calling thread's stream
+  // This ensures thread-safe profiling when using the stream pool
+  auto current_stream = getCurrentMPSStream();
+  [current_stream->commandBuffer() addCompletedHandler:^(id<MTLCommandBuffer> cb) {
     CFTimeInterval gpuTime = cb.GPUEndTime > cb.GPUStartTime ? (cb.GPUEndTime - cb.GPUStartTime) * 1000.0 : 0.;
     CFTimeInterval schedulingTime =
         cb.kernelEndTime > cb.kernelStartTime ? (cb.kernelEndTime - cb.kernelStartTime) * 1000.0 : 0.;
@@ -482,8 +484,8 @@ void MPSProfiler::addProfilerCompletedHandler(BaseInfo& info, SyncType syncType)
     hasPendingCompletionHandlers = false;
   }];
 
-  m_stream->synchronize((m_profile_options & ProfileOptions::WAIT_UNTIL_COMPLETED) ? SyncType::COMMIT_AND_WAIT
-                                                                                   : syncType);
+  current_stream->synchronize((m_profile_options & ProfileOptions::WAIT_UNTIL_COMPLETED) ? SyncType::COMMIT_AND_WAIT
+                                                                                          : syncType);
 }
 
 void MPSProfiler::logOperationsProfilingStats(std::FILE* f) const {
diff --git a/aten/src/ATen/mps/MPSStream.h b/aten/src/ATen/mps/MPSStream.h
index 10627cfc..9f3cbf96 100644
--- a/aten/src/ATen/mps/MPSStream.h
+++ b/aten/src/ATen/mps/MPSStream.h
@@ -4,6 +4,10 @@
 
 #include <cstdint>
 #include <utility>
+#include <array>
+#include <atomic>
+#include <memory>
+#include <mutex>
 
 #include <ATen/mps/MPSDevice.h>
 #include <c10/core/DeviceGuard.h>
@@ -130,23 +134,124 @@ class TORCH_API MPSStream {
 };
 
 /**
- * Get the current MPS stream
+ * Get the current MPS stream for the calling thread.
+ * Returns the thread-local current stream, or default stream if not set.
  */
 TORCH_API MPSStream* getCurrentMPSStream();
 
 /**
- * Get the default MPS stream
+ * Get the default MPS stream (stream 0).
+ * This is the stream used by single-threaded code and is always available.
  */
 TORCH_API MPSStream* getDefaultMPSStream();
 
+/**
+ * Get a stream from the MPS stream pool using round-robin allocation.
+ * Use this when you need a dedicated stream for parallel execution.
+ */
+TORCH_API MPSStream* getStreamFromPool();
+
+/**
+ * Set the current stream for the calling thread.
+ * This affects subsequent getCurrentMPSStream() calls from this thread.
+ */
+TORCH_API void setCurrentMPSStream(MPSStream* stream);
+
+//-----------------------------------------------------------------
+//  MPSStreamPool
+//-----------------------------------------------------------------
+// Stream pool for enabling parallel MPS inference.
+// Modeled after c10::cuda::CUDAStream pool design.
+//
+// Key design principles:
+// - 32 streams per pool (matching CUDA's kStreamsPerPool)
+// - Round-robin allocation via atomic counter
+// - Thread-local current stream tracking
+// - Lazy initialization on first use
+// - Default stream (index 0) always available for backward compatibility
+
+static constexpr int kMPSStreamsPerPoolBits = 5;
+static constexpr int kMPSStreamsPerPool = 1 << kMPSStreamsPerPoolBits;  // 32 streams
+
+class TORCH_API MPSStreamPool {
+ public:
+  /**
+   * Get the singleton MPSStreamPool instance.
+   * Thread-safe via static initialization.
+   */
+  static MPSStreamPool& instance();
+
+  /**
+   * Get a stream from the pool using round-robin allocation.
+   * Returns streams 1 through kMPSStreamsPerPool-1 (stream 0 is default).
+   */
+  MPSStream* acquireStream();
+
+  /**
+   * Get the default stream (stream 0).
+   * This is always the same stream, used for single-threaded code.
+   */
+  MPSStream* getDefaultStream();
+
+  /**
+   * Get stream by index (0 to kMPSStreamsPerPool-1).
+   * Used internally and for advanced use cases.
+   */
+  MPSStream* getStream(size_t index);
+
+  /**
+   * Get the thread-local current stream.
+   * Returns default stream if no stream has been set for this thread.
+   */
+  static MPSStream* getCurrentStream();
+
+  /**
+   * Set the thread-local current stream.
+   */
+  static void setCurrentStream(MPSStream* stream);
+
+  /**
+   * Get number of streams in the pool.
+   */
+  static constexpr size_t poolSize() { return kMPSStreamsPerPool; }
+
+ private:
+  MPSStreamPool();
+  ~MPSStreamPool();
+
+  // Non-copyable, non-movable
+  MPSStreamPool(const MPSStreamPool&) = delete;
+  MPSStreamPool& operator=(const MPSStreamPool&) = delete;
+  MPSStreamPool(MPSStreamPool&&) = delete;
+  MPSStreamPool& operator=(MPSStreamPool&&) = delete;
+
+  // Stream storage - lazily initialized
+  std::array<std::unique_ptr<MPSStream>, kMPSStreamsPerPool> streams_;
+
+  // Atomic counter for round-robin allocation (starts at 1 to skip default stream)
+  std::atomic<uint32_t> next_stream_idx_{1};
+
+  // Initialization flag for lazy stream creation
+  std::atomic<bool> initialized_{false};
+
+  // Mutex for thread-safe stream creation
+  std::mutex stream_creation_mutex_;
+
+  void ensureInitialized();
+  MPSStream* createStream(size_t index);
+};
+
 //-----------------------------------------------------------------
-//  MPSStreamImpl
+//  MPSStreamImpl (DEPRECATED - for backward compatibility)
 //-----------------------------------------------------------------
+// NOTE: MPSStreamImpl is kept for backward compatibility with existing code.
+// New code should use MPSStreamPool directly.
 
 class TORCH_API MPSStreamImpl {
  public:
   /**
    * Gets single instance of the MPSStream.
+   * DEPRECATED: Use getDefaultMPSStream() or MPSStreamPool instead.
    */
   static MPSStream* getInstance();
 
diff --git a/aten/src/ATen/mps/MPSStream.mm b/aten/src/ATen/mps/MPSStream.mm
index 71325bd6..a4e69ba8 100644
--- a/aten/src/ATen/mps/MPSStream.mm
+++ b/aten/src/ATen/mps/MPSStream.mm
@@ -3,6 +3,7 @@
 #include <ATen/mps/MPSAllocatorInterface.h>
 #include <ATen/mps/MPSProfiler.h>
 #include <ATen/mps/MPSStream.h>
+#include <thread>
 
 @interface MPSGraphExecutionDescriptor ()
 @property(readwrite, atomic) BOOL enableCommitAndContinue;
@@ -267,26 +268,156 @@ void MPSStream::executeMPSGraph(MPSGraph* mpsGraph, NSDictionary* feeds, NSDicti
 }
 
 //-----------------------------------------------------------------
-//  MPSStreamImpl
+//  MPSStreamPool
+//-----------------------------------------------------------------
+
+// Thread-local storage for current stream per thread
+// nullptr means use the default stream (stream 0)
+static thread_local MPSStream* tls_current_stream = nullptr;
+
+MPSStreamPool& MPSStreamPool::instance() {
+  // Thread-safe singleton via static local variable (C++11 guarantee)
+  static MPSStreamPool pool;
+  return pool;
+}
+
+MPSStreamPool::MPSStreamPool() {
+  // Streams are lazily initialized on first access
+}
+
+MPSStreamPool::~MPSStreamPool() {
+  // Streams are cleaned up automatically via unique_ptr
+}
+
+void MPSStreamPool::ensureInitialized() {
+  // Double-checked locking pattern for lazy initialization
+  if (!initialized_.load(std::memory_order_acquire)) {
+    std::lock_guard<std::mutex> lock(stream_creation_mutex_);
+    // Re-check under lock
+    if (!initialized_.load(std::memory_order_relaxed)) {
+      // Only stream 0 (default) needs to exist initially
+      // Other streams are created on-demand
+      if (streams_[0] == nullptr) {
+        streams_[0] = std::unique_ptr<MPSStream>(
+            new MPSStream(Stream(Stream::UNSAFE, c10::Device(DeviceType::MPS, 0), 0)));
+      }
+      initialized_.store(true, std::memory_order_release);
+    }
+  }
+}
+
+MPSStream* MPSStreamPool::createStream(size_t index) {
+  TORCH_CHECK(index < kMPSStreamsPerPool,
+              "Stream index ", index, " out of range [0, ", kMPSStreamsPerPool, ")");
+
+  // Thread-safe stream creation with double-checked locking
+  if (streams_[index] == nullptr) {
+    std::lock_guard<std::mutex> lock(stream_creation_mutex_);
+    // Re-check under lock to avoid double creation
+    if (streams_[index] == nullptr) {
+      // Create a new stream with unique stream ID
+      // Stream IDs are index values for simplicity
+      streams_[index] = std::unique_ptr<MPSStream>(
+          new MPSStream(Stream(Stream::UNSAFE, c10::Device(DeviceType::MPS, 0),
+                              static_cast<StreamId>(index))));
+    }
+  }
+  return streams_[index].get();
+}
+
+MPSStream* MPSStreamPool::getDefaultStream() {
+  ensureInitialized();
+  return streams_[0].get();
+}
+
+MPSStream* MPSStreamPool::getStream(size_t index) {
+  ensureInitialized();
+  if (index >= kMPSStreamsPerPool) {
+    return getDefaultStream();
+  }
+  if (streams_[index] == nullptr) {
+    return createStream(index);
+  }
+  return streams_[index].get();
+}
+
+MPSStream* MPSStreamPool::acquireStream() {
+  ensureInitialized();
+
+  // Round-robin allocation starting from stream 1
+  // (stream 0 is reserved as the default stream)
+  uint32_t idx = next_stream_idx_.fetch_add(1, std::memory_order_relaxed);
+
+  // Map to range [1, kMPSStreamsPerPool-1]
+  // This ensures we never return stream 0 from acquireStream()
+  size_t stream_idx = 1 + (idx % (kMPSStreamsPerPool - 1));
+
+  return getStream(stream_idx);
+}
+
+// Track whether the main thread has been assigned (first thread to use MPS)
+static std::atomic<bool> main_thread_assigned{false};
+static std::thread::id main_thread_id;
+
+MPSStream* MPSStreamPool::getCurrentStream() {
+  if (tls_current_stream != nullptr) {
+    return tls_current_stream;
+  }
+
+  // First thread to use MPS becomes the "main thread" and gets the default stream
+  // This ensures backward compatibility with single-threaded code
+  bool expected = false;
+  if (main_thread_assigned.compare_exchange_strong(expected, true)) {
+    // This is the first thread - assign it stream 0 (default stream)
+    main_thread_id = std::this_thread::get_id();
+    tls_current_stream = MPSStreamPool::instance().getDefaultStream();
+  } else if (std::this_thread::get_id() == main_thread_id) {
+    // Main thread returning - use default stream
+    tls_current_stream = MPSStreamPool::instance().getDefaultStream();
+  } else {
+    // Non-main thread: auto-acquire a stream from the pool
+    // This enables parallel execution without explicit stream management
+    tls_current_stream = MPSStreamPool::instance().acquireStream();
+  }
+
+  return tls_current_stream;
+}
+
+void MPSStreamPool::setCurrentStream(MPSStream* stream) {
+  tls_current_stream = stream;
+}
+
+//-----------------------------------------------------------------
+//  MPSStreamImpl (DEPRECATED - for backward compatibility)
 //-----------------------------------------------------------------
 
 MPSStream* MPSStreamImpl::_stream = nullptr;
 
 MPSStream* MPSStreamImpl::getInstance() {
-  if (_stream == nullptr) {
-    _stream = new MPSStream(Stream(Stream::UNSAFE, c10::Device(DeviceType::MPS, 0), 0));
-  }
-  return _stream;
+  // Redirect to the pool's default stream for backward compatibility
+  return MPSStreamPool::instance().getDefaultStream();
 }
 
 MPSStreamImpl::MPSStreamImpl() {}
 
+//-----------------------------------------------------------------
+//  Public API Functions
+//-----------------------------------------------------------------
+
 MPSStream* getCurrentMPSStream() {
-  return getDefaultMPSStream();
+  return MPSStreamPool::getCurrentStream();
 }
 
 MPSStream* getDefaultMPSStream() {
-  return MPSStreamImpl::getInstance();
+  return MPSStreamPool::instance().getDefaultStream();
+}
+
+MPSStream* getStreamFromPool() {
+  return MPSStreamPool::instance().acquireStream();
+}
+
+void setCurrentMPSStream(MPSStream* stream) {
+  MPSStreamPool::setCurrentStream(stream);
 }
 
 } // namespace at::mps
diff --git a/aten/src/ATen/native/mps/OperationUtils.h b/aten/src/ATen/native/mps/OperationUtils.h
index f9cd28ca..0bfdff91 100644
--- a/aten/src/ATen/native/mps/OperationUtils.h
+++ b/aten/src/ATen/native/mps/OperationUtils.h
@@ -297,7 +297,9 @@ struct MPSKernelCache {
     serialQueue_ = dispatch_queue_create("kernel cache queue", DISPATCH_QUEUE_SERIAL);
   }
 
-  static MPSKernelCache* _instance_cache;
+  // THREAD-SAFETY FIX: Each thread gets its own kernel cache to prevent
+  // concurrent encoding of shared kernel objects which may not be thread-safe.
+  static thread_local MPSKernelCache* _instance_cache;
   std::unordered_map<MPSCacheKey, CacheEntry> cache_;
   dispatch_queue_t serialQueue_ = nullptr;
 };
@@ -402,7 +404,10 @@ struct MPSGraphCache {
   // MPSProfiler.h in header OperationUtils.h
   void profileCachedGraph(const CacheEntry& cacheEntry) const;
 
-  static MPSGraphCache* _instance_cache;
+  // THREAD-SAFETY FIX: Each thread gets its own graph cache to prevent
+  // concurrent encoding of shared MPSGraph objects which is not thread-safe.
+  // This enables true parallel nn.Module inference across multiple threads.
+  static thread_local MPSGraphCache* _instance_cache;
   std::unordered_map<MPSCacheKey, CacheEntry> cache_;
   dispatch_queue_t serialQueue_ = nullptr;
 };
diff --git a/aten/src/ATen/native/mps/OperationUtils.mm b/aten/src/ATen/native/mps/OperationUtils.mm
index bf3e9420..4031325d 100644
--- a/aten/src/ATen/native/mps/OperationUtils.mm
+++ b/aten/src/ATen/native/mps/OperationUtils.mm
@@ -769,9 +769,11 @@ std::string get_mem_format_string(c10::MemoryFormat memory_format) {
   return mem_format_key;
 }
 
-MPSGraphCache* MPSGraphCache::_instance_cache = nullptr;
+// THREAD-SAFETY FIX: Per-thread graph cache for parallel nn.Module inference
+thread_local MPSGraphCache* MPSGraphCache::_instance_cache = nullptr;
 
-MPSKernelCache* MPSKernelCache::_instance_cache = nullptr;
+// THREAD-SAFETY FIX: Per-thread kernel cache for parallel inference
+thread_local MPSKernelCache* MPSKernelCache::_instance_cache = nullptr;
 
 void MPSGraphCache::profileCachedGraph(const CacheEntry& cacheEntry) const {
   auto& profiler = getMPSProfiler();
diff --git a/aten/src/ATen/native/mps/operations/Linear.mm b/aten/src/ATen/native/mps/operations/Linear.mm
index 219086ed..6e53eee9 100644
--- a/aten/src/ATen/native/mps/operations/Linear.mm
+++ b/aten/src/ATen/native/mps/operations/Linear.mm
@@ -6,18 +6,35 @@
 #include <ATen/native/mps/OperationUtils.h>
 #include <ATen/ops/linear_backward_native.h>
 #include <ATen/ops/linear_native.h>
+#include <mutex>
 
 namespace at::native {
 
 using namespace mps;
 
+// THREAD-SAFETY: Global mutex for MPSNDArrayMatrixMultiplication encoding.
+// Apple's MPS framework has internal shared state that makes concurrent encoding
+// of MPSNDArrayMatrixMultiplication kernels unsafe, even with per-thread instances.
+// This mutex serializes the no-graph linear path to prevent crashes.
+static std::mutex s_linear_nograph_mutex;
+
 static void _mps_linear_nograph(const Tensor& input, const Tensor& weight, const Tensor& bias, Tensor& output) {
   bool is_bias_defined = bias.defined();
 
+  // THREAD-SAFETY: Serialize no-graph linear operations.
+  // MPSNDArrayMatrixMultiplication has internal Apple framework state that is not thread-safe
+  // even when using per-thread kernel instances. This mutex prevents concurrent encoding.
+  std::lock_guard<std::mutex> lock(s_linear_nograph_mutex);
+
   MPSStream* mpsStream = getCurrentMPSStream();
   id<MTLDevice> device = MPSDevice::getInstance()->device();
 
+  // THREAD-SAFETY FIX: Look up the kernel BEFORE dispatch_sync.
+  // dispatch_sync may run the block on a GCD thread pool thread, not the calling thread.
+  // Since MPSKernelCache is thread_local, we must access it on the original Python thread.
+  // Note: We need separate cache entries for bias vs no-bias cases since they have different sourceCount.
   const std::string key = "mps_linear" + getTensorsStringKey({input, weight, bias}, true, true);
+
   dispatch_sync_with_rethrow(mpsStream->queue(), ^() {
     @autoreleasepool {
       mpsStream->endKernelCoalescing();
