// Copyright 2024-2025 Andrew Yates
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

/**
 * Kokoro Prosody Parser
 *
 * Parses SSML-style prosody annotations from text and maps them to phonemes.
 * Supports emphasis, breaks, rate, pitch, volume, and emotions.
 *
 * Example:
 *   Input:  "I <em>really</em> need this<break time='300ms'/>."
 *   Output: clean_text = "I really need this."
 *           annotations = [{char_start=2, char_end=8, type=EMPHASIS}]
 *           breaks = [{after_char=19, duration_ms=300}]
 *
 * See: reports/main/PROSODY_DESIGN.md
 */

#include <string>
#include <vector>
#include <cstddef>
#include "prosody_types.h"

namespace kokoro {

/**
 * A prosody annotation span in the clean text.
 */
struct ProsodyAnnotation {
    size_t char_start;      // Start character index in clean text
    size_t char_end;        // End character index in clean text (exclusive)
    ProsodyType type;       // Prosody type
    float value;            // Optional parsed value (typically multiplier; 1.0 = no change)

    ProsodyAnnotation(size_t start, size_t end, ProsodyType t, float v = 0.0f)
        : char_start(start), char_end(end), type(t), value(v) {}
};

/**
 * A break/pause instruction.
 */
struct ProsodyBreak {
    size_t after_char;      // Insert break after this character index
    int duration_ms;        // Break duration in milliseconds

    ProsodyBreak(size_t pos, int ms)
        : after_char(pos), duration_ms(ms) {}
};

/**
 * Result of parsing prosody markers from text.
 */
struct ParsedProsody {
    std::string clean_text;                    // Text with all markers removed
    std::vector<ProsodyAnnotation> annotations; // Prosody spans
    std::vector<ProsodyBreak> breaks;          // Break instructions
};

/**
 * Per-phoneme prosody information.
 * Generated by mapping character-level annotations to phonemes.
 */
struct PhonemeProsody {
    std::vector<ProsodyType> mask;   // Per-phoneme prosody type
    std::vector<int> break_after_ms; // Pause duration after each phoneme (0 = none)

    PhonemeProsody() = default;

    explicit PhonemeProsody(size_t num_phonemes)
        : mask(num_phonemes, ProsodyType::NEUTRAL)
        , break_after_ms(num_phonemes, 0) {}

    size_t size() const { return mask.size(); }
    bool empty() const { return mask.empty(); }

    // Check if any prosody is active
    bool has_prosody() const {
        for (auto t : mask) {
            if (t != ProsodyType::NEUTRAL) return true;
        }
        for (auto b : break_after_ms) {
            if (b > 0) return true;
        }
        return false;
    }
};

/**
 * Parse SSML-style prosody markers from text.
 *
 * Supported markers:
 *   <em>text</em>                        - Emphasis
 *   <strong>text</strong>                - Strong emphasis
 *   <emphasis level="moderate">          - W3C SSML emphasis
 *   <break time="500ms"/>                - Pause
 *   <break strength="medium"/>           - Named pause
 *   <prosody rate="slow">text</prosody>  - Speaking rate
 *   <prosody pitch="high">text</prosody> - Pitch
 *   <emotion type="angry">text</emotion> - Emotion
 *   <whisper>text</whisper>              - Whisper
 *   <loud>text</loud>                    - Loud
 *   <question>text</question>            - Question intonation
 *
 * @param text Input text with markers
 * @return ParsedProsody with clean text and annotations
 */
ParsedProsody parse_prosody_markers(const std::string& text);

/**
 * Map character-level prosody annotations to phoneme indices.
 *
 * @param parsed Parsed prosody with character indices
 * @param phonemes Phoneme string from G2P
 * @param char_to_phoneme Mapping from clean text character index to phoneme index
 *                        (size = clean_text.length(), -1 for unmapped chars)
 * @return PhonemeProsody with per-phoneme prosody masks
 */
PhonemeProsody map_to_phonemes(
    const ParsedProsody& parsed,
    const std::string& phonemes,
    const std::vector<int>& char_to_phoneme
);

/**
 * Simplified mapping when character-to-phoneme alignment isn't available.
 * Uses heuristic: each character maps to roughly (phoneme_count / char_count) phonemes.
 *
 * @param parsed Parsed prosody with character indices
 * @param num_phonemes Number of phonemes/tokens
 * @return PhonemeProsody with per-phoneme prosody masks
 */
PhonemeProsody map_to_phonemes_simple(
    const ParsedProsody& parsed,
    size_t num_phonemes
);

}  // namespace kokoro
